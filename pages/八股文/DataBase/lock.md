# MySQL锁

## 锁粒度

MySQL提供了两种封锁粒度：行级锁、表级锁。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁冲突的可能就越少，系统的并发程度就越高。锁的各种操作（包括获取锁、释放锁 以及 检查锁状态）都需要消耗资源。

MySQL不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式实现了锁机制，服务器层完全不了解存储引擎中的锁实现：

+ InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁（table-level locking），但默认情况下采用行级锁。
+ MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）
+ BDB存储引擎采用的是页面锁（page-level locking），也支持表级锁

不同粒度锁的比较：

+ 表级锁：开销小，加锁快；不会出现死锁；锁粒度度大，发生冲突的高度最高，并发度最低。
    + 存储引擎通过 总是一次性同时获取所有需要的锁 以及 总是按相同的顺序获取表锁 来避免死锁。
+ 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突概率最低，并发度也最高。
    + 最大程度的支持并发，同时也带来了最大的锁开销。
    + 在InnoDB中，除单个SQL组成的事物外，锁是逐步获得的，这就决定了在InnoDB中发生死锁是可能的。
    + 行级锁只在存储引擎层实现，而MySQL服务器层没有实现。
    + 行级锁更适合于有大量索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。
+ 页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。

## 锁类型

> 基于InnoDB

+ 共享锁（读锁，S）：其他事务可以读，但不能写。
    + 一个事务对数据对象A加了S锁，可以对A进行读操作，但是不能进行更新操作。加锁期间其他事务能对A加S锁，但是不能加X锁。
+ 排他锁（写锁，X）：其他事务不能读，也不能写。
    + 一个事务对数据对象A加了X锁，就可以对A进行读取和更新操作。加锁期间其他事务不能对A加任务锁。

为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks）：意向共享锁（IS）、意向排他锁（IX）。IS/IX都是表锁，用来表示一个事务想要在表中的某个数据行上加S锁或X锁。有以下两个规定：

+ 一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或更强的锁
+ 一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁

通过引入意向锁，事务T想要对表A加X锁，只需要检测是否有其他事务对表A加了X/IX/IS锁，后两者标识有其他使用给该表中的某行加了X/S锁。

锁的兼容关系

|锁|X|IX|S|IS|
|---|---|---|---|---|
|X|||||
|IX||Y||Y|
|S|||Y|Y|
|IS||Y|Y|Y|

+ 任意IS/IX锁之间都是兼容的，他们只表示想要加锁，而不是真正加锁
+ S锁只有S锁和IS锁兼容，也就是说事务T想要对数据行加S锁，其他事务可以获得对表或者表中行的S锁

## 隐式与显示锁定

MySQL的InnoDB存储引擎采用两段锁协议（加锁和解锁分为两个阶段进行），会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同时时刻被释放，这被称为隐式锁定。

InnoDB也可以使用特定的语句进行显示锁定：

```SQL
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```

## 参考

1. [MySQL锁总结](https://zhuanlan.zhihu.com/p/29150809)
# MySQL事务

> 基于InnoDB

数据库事务指的是：满足ACID特性的一组操作。

## ACID

+ 原子性（Atomicity）：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
    + 回滚可以用日志实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
+ 一致性（Consistency）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据库的读结果都是相同的。
+ 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。
+ 持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中，即使系统发生崩溃，事务执行的结果也不能丢失。
    + 可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复

可以按如下思路理解：
+ 只有满足一致性，事务的执行结果才是正确的
+ 在无并发的情况下，事务串行执行，隔离型一定能满足。此时只要能满足原子性，就能满足一致性
+ 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性
+ 事务满足持久化，是为了能够应对数据库崩溃的情况

## 并发一致性问题

在并发情况下，不考虑事务的隔离性，会有以下并发一致性问题：

1. 读脏数据：T1修改了一个数据，T2随后读取这个数据，如果T1撤销了这次修改，T2读取的就是脏数据
2. 不可重复读：T2读取了一个数据，T1对该数据做了修改，如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同
3. 幻影读：T1读取某个**范围**的数据，T2在这个范围插入更新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同

产生并发不一致问题的主要原因，是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

## 隔离级别

MySQL支持SQL标准定义的四种隔离级别：

1. 读未提交（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的
2. 读提交（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。即，一个事务所做的修改在提交之前对其他事务是不可见的
3. 可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一个数据的结果是一样的
4. 串性化（SERIALIZABLE）：强制事务串性执行

从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，**可重复读**是MySQL的默认级别。

事务隔离就是为了解决上面并发一致性的问题，下面展示了4中隔离级别对这三个问题的解决程度：

|隔离级别|脏读|不可重复读|幻读|
|---|---|---|---|
|读未提交|可能|可能|可能|
|读提交||可能|可能|
|可重复读|||可能|
|串性化||||

### 修改丢失

如果多个线程操作，基于同一个查询结果对表中的记录进行修改，那么后修改的记录会覆盖前面修改的记录，前面的修改丢失掉了，这就叫丢失更新。

丢失更新分为两类。第一类丢失更新：回滚丢失；第二类丢失更新：覆盖丢失。第一类丢失更新属程序bug（数据库会解决），第二类丢失更新的解决办法就是加锁：

+ 悲观锁：假定这样的问题是高概率的，最好一开始就锁住
    + 添加共享锁`select * from xxx lock in share mode;`
    + 添加排他锁`select * from xxx for update;`
+ 乐观锁：假定这样的问题是小概率的，最后一步做更新的时候再锁住，免得锁住时间太长影响其他人操作
    + 在表中增加timestamp字段，在执行插入或更新时记录最新时间到该字段上
    + 在修改数据时检查timestamp类型的字段是否改变判断当前的更新基于的查询是否已经过时
    > 或者用版本号字段更合适？
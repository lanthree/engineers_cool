# 172. 阶乘后的零

[原题链接](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

问题可以转换为统计阶乘所有数字的质因数分解中2的个数和5的个数，取其最小值。但是这个计数过程直观上是一个O(nlogn)的复杂度：

```cpp
class Solution {
public:
    int trailingZeroes(int n) {
        int cnt_2 = counter(n, 2);
        int cnt_5 = counter(n, 5);
        return min(cnt_2, cnt_5);
    }

private:
    int counter(int n, int base) {
        int cnt = 0;
        while (n) {
            if (n % base == 0) {
                int now_n = n;
                while (now_n != 0 && now_n % base == 0) {
                    cnt++;
                    now_n /= base;
                }
                n -= base;
            } else {
                n -= (n%base);
            }
        }
        return cnt;
    }
};
```

一个简单的优化思路是：去掉`base`为2的计算，因为5总是少于2：

```cpp
class Solution {
public:
    int trailingZeroes(int n) {
        return counter(n, 5);
    }

private:
    int counter(int n, int base) {
        int cnt = 0;
        while (n) {
            if (n % base == 0) {
                int now_n = n;
                while (now_n != 0 && now_n % base == 0) {
                    cnt++;
                    now_n /= base;
                }
                n -= base;
            } else {
                n -= (n%base);
            }
        }
        return cnt;
    }
};
```
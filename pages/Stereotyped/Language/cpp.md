# C++

## 程序编译过程

编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。

+ 编译预处理：处理以`#`开头的指令
+ 编译、优化：将源码`.cpp`文件翻译成`.s`汇编代码
+ 汇编：将汇编代码`.s`翻译成机器指令`.o`文件
+ 链接：汇编程序生成的木匾文件，即`.o`文件，并不会立即执行，因为可能会出现：`.cpp`文件中的函数引用了另一个`.cpp`文件中定义的符号或者调用了某个库文件中的函数。那链接的目的。就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的文件

链接分为两种：
+ 静态链接：代码从其所在的静态链接库中拷贝到最终的可执行文件中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中
+ 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址空间

## 内存管理

C++内存分区：栈、堆、全局/静态存储区、常量存储区、代码区

+ 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放
+ 堆：动态申请的内存空间，就是由`malloc`/`new`分配的内存块，有程序员控制它的分配和释放，如果程序执行结束没有释放，操作系统会自动回收
+ 全局/静态存储区（`.bss`段和`.data`段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在C语言中，为初始化的放在`.bss`段中，初始化的放在`.data`段中，C++中不再区分
+ 常量存储区（`.data`段）：存放的是常量，不允许修改，程序运行结束自动释放
+ 代码区（`.text`段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里

以上存储区在内容中的分布是如下形式（从低地址到高地址）：`.text`段 -> `.data`段 -> 堆 -> `unused`-> 栈 -> `env`

## 栈和堆的区别

||栈|堆|
|---|---|---|
|申请方式|系统自动分配|程序主动申请|
|申请后系统响应|分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出|堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该结点从链表中删除，大多数系统中该块空间的首地址存放的本次分配空间的大小，便于释放，将该快空间上的剩余空间再次连接在空闲链表上|
|地址|栈在内存中是连续的一块空间（向低地址扩展）|堆在内存中的空间（向高地址扩展）是不连续的|
|申请效率|申请效率高|申请效率低，使用起来方便但是容易产生碎片|
|存放的内容|局部变量，函数的参数|由程序控制|

## 虚表

+ [虚表](https://leehao.me/C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%89%96%E6%9E%90/)

## 内存对齐

内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中

内存对齐的原则：

1. 结构体变量的首地址能够被其 最宽基本类型成员大小 与 对齐基数中 的较小者所整除
2. 结构体每个成员相对于结构体首地址的偏移量（offset）都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节（internal padding）
3 结构体的总大小为 结构体最宽基本类型成员大小 与 对齐基数中的较小者 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）

> 32位操作系统，对齐基数4字节；64位操作系统，对齐基数8字节。

[packed](https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#Common-Variable-Attributes)属性可以指定变量或结构体以1字节对齐（不浪费空间）

```cpp
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

## 智能指针有哪几种，智能指针的实现原理

智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存而提出的。C++11中封装在了`<memory>`头文件中

C++11中智能指针包括以下三种：

+ 共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过`use_count()`查看资源所有者的个数，可以通过`unique_ptr`、`weak_ptr`来构造，调用`release()`释放资源的所有权，计数减1，当计数减为0时，会自动释放内存空间，从而避免了内存泄漏。
+ 独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用`move()`函数）。
+ 弱指针（weak_ptr）：指向`shared_ptr`指向的对象，能够解决有`shared_ptr`带来的循环引用问题

`unique_ptr`移动：
```cpp
std::unique_ptr<A> ptr1(new A());
std::unique_ptr<A> ptr2 = std::move(ptr1);
```

## 设计一个不可被复制拷贝的基类

```cpp
class noncopyable
{
    noncopyable() {}
    ~noncopyable() {}

    noncopyable( const noncopyable& ) = delete;
    noncopyable& operator=( const noncopyable& ) = delete;
};
```

## 什么是面向对象，面向对象的三大特性

面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。

面向对象的三大特性：

+ 封装：将 具体的实现过程和数据 封装成一个函数，只能通过接口进行访问，降低耦合性。
+ 继承：子类继承父类的特征和行为，子类有父类的非`private`方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被`final`关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。
+ 多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式

## 重载、重写、隐藏的区别

概念解释：

+ 重载：指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用那个函数，重载不关心函数返回类型。
+ 隐藏：指派生类的函数屏蔽了与其同名的基类函数，只要函数同名，不管参数列表是否相同，基类函数都被隐藏。
    + 可以加上基类类名调用基类被隐藏的函数`child.Father::func();`
+ 重写（override）：指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须统计类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有`virutal`修饰。

## volatile的作用

作用：当对象的值可能在程序的控制或检测之外被改变时，应该将对象声明为`volatile`，告知编译器不应对这样的对应进行优化

对编译器的影响：

使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。

volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

我们可以使用volatile关键字试图阻止过度优化，volatile基本可以做到两件事情：

1. 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；（缓存一致性协议、轻量级同步）
2. 阻止编译器调整操作volatile变量的指令排序。

## 参考

1. [GCC, the GNU Compiler Collection](https://gcc.gnu.org/)
2. [Declaring Attributes of Functions](https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes)

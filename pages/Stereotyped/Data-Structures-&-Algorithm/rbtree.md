# 红黑树

## 定义

红黑树是一种具有下列着色性质的二叉查找树：

1. 每一个结点或者着红色，或者着黑色
2. 根是黑色的
3. 如果一个结点是红色的，那么它的子结点必须是黑色的
4. 从一个几点到一个NULL指针的每一条路径都必须包含相同数目的黑色结点

一个典型的红黑树如下图所示：

![图1：红黑树的例子](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/rbtree.svg)

## 插入

首先，考虑插入过程，通常把**新项**作为树叶放到树种（通过二叉查找树找到合适的位置）。然后考虑着色以及平衡的事情。如果把该项涂成黑色，那么在不做其他调整情况下，会违反性质4。如果把该项涂成红色，在父结点是黑色时，插入操作完成，在父结点是红色时，为了不违反性质3，也需要做调整（着色改变 和 树的旋转）。以下以**涂成红色**为例讨论。

?> 感觉涂成黑色也可以？只是当前看到的这个没有讨论？

如果新项（着红色）的父结点是黑色，那么插入完成。如果父结点是红色，那么有以下几种情况（每种都有一个镜像对称）需要考虑。（另外以下讨论中，以NULL为黑色）

### 父结点的兄弟结点是黑色（情况A）

> 以下讨论都，令X是新插入结点，P是父结点，S是该父结点的兄弟结点（若存在），G是祖父结点

如果S结点是黑色（例如在图1中插入8），在这种情况下，只有X和P是红色，G是黑色（G如果不是黑色，那么在插入新结点前，就会有`红G->红P`的违反性质3的情况）。X、P、G可以行政一个**一字型链**或者**之字形链**。下图指出，当P是G的左儿子时，应如何旋转。（还有镜像的P是右儿子的情况，自行想象）

![如果S是黑色，通用的单旋转和之字形旋转有效](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/rbtree_insert_S_B.svg)

这两种情况下，子树的新根颜色保持不变，不会打破新跟与原子树的父结点的着色约束。另外，新根到A、B、C的叶子上的黑色结点个数保持不变：

1. 情况1：A为空，不讨论；旋转前，G到B经历1个黑色结点，G到C经历2个黑色结点，旋转后 新根到B、C经历的黑色结点个数一样。
2. 情况2：B1、B2为空，不讨论；旋转前，G到A经历1个黑色结点，G到C经历2个黑色结点，旋转后 新根到A、C经历的黑色结点个数一样。

### 父结点的兄弟结点是红色（情况B）

如果S结点是红色（例如在图1中插入79），在这种情况下，X、P、S是红色，G是黑色。此时，从跟结点G到A、B、C只有1个黑结点，在旋转后，我们也希望新根到A、B、C的黑色结点树是1（这样才能保证，新根到A、B、C的叶子的黑色结点数一致）。又由于不能有连续的红色结点，所以S和新根需要是红色，而G和X是黑色：

![如果S是红色，通用的单旋转和之字形旋转 并调整颜色后，新根是红色](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/rbtree_insert_S_R.svg)

子树是平衡了，但是子树的父结点（R）可能是红色。这时，需要判断结点R的兄弟结点是黑色还是红色，然后重新按上面讨论的 情况A、情况B 处理，直到不再有两个相连的红色结点。

## 删除

!> “删除”操作的内容，基本来自[Ref3](https://www.jianshu.com/p/84416644c080)。

1. 要删除的结点，没有子结点，考虑两种情况：
    1. 该结点为红色，直接删除即可。
    2. 该结点为黑色，则需要进行平衡操作，下图展示了这种需要平衡的情况
2. 要删除的结点，有一个子结点。此时，要删除的结点一定是黑色，其子结点一定是红色。那么可以让删除结点的父结点连接到该子结点，并着黑色。
3. 有两个子结点时。与二叉搜索树一样，把 左子结点的最大值/右子结点的最小值 复制到要删除的结点上，把问题转换为删除被复制的结点，递归此过程，直到把问题转换为情况1 或者 情况2。

![图4：删除 黑色 无子结点的结点 的情况](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/rbtree_delete_1_2_note.svg)

> 以上过程，总体上，是把删除结点的问题，归结为删除**最下层子结点**的问题：如果该**最下层子结点**是红色（情况1.1、情况2），那么可以安全的删除。如果该**最下层子结点**是黑色（情况1.2），那需要做平衡操作。

### 平衡操作

约定结点名称如下：

![](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/rbtree_rl.svg)

另外，记`h(A->B->NIL)`表示从A走到B再走到某一个NIL结点的黑色结点数量。

接下来考虑如何平衡，首先需要平衡是因为删除了一个黑色结点D（图4），导致其父结点走这个儿子的路径的黑色结点树少了1。那么，为了平衡有两种操作：

1. 操作1：`h(P->N->NIL)`不变，`h(P->S->NIL)`减1。这种平衡操作会使得`h(G-P->NIL)`减1，此时需要将P当成新的N，向上递归处理。
2. 操作2：`h(P->N->NIL)`加1，`h(P->S->NIL)`不变。也就是回复原来的黑色结点数。

#### N为跟结点

无需平衡操作。

#### S为黑色

先考虑，S的子结点全黑的情况：
1. P为黑：此时可以通过S着红色，来达到**操作1**，然后以P为新的需平衡结点，向上递归处理。
2. P为红：此时可以通过交换P、S的着色（P：红->黑；S：黑->红），来达到**操作2**，完成平衡。

![](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/rbtree_delete_sb.svg)

再考虑，S的子结点不全黑：
1. S为左子，SL红；S为右子，SR红（镜像问题）
2. S为左子，SL黑；S为右子，SR黑（镜像问题）

对于情况1，以P为支点，把S旋转为P的新父，交换S、P着色，最后把 SL红 / SR红（镜像问题）着黑色，完成平衡。

![](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/rbtree_delete_snotallb.svg)

> 通常旋转后，新的P节点往往都会涂成原P的颜色：一是为了让G-P不会颜色冲突；二是保持经过P的路径黑色数量不变。

对于情况2，我们可以通过某种方法，把该问题转换为情况1：以S为支点，把 SR红 / SL红（镜像问题）旋转为S的新父，并交换着色。

![](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/rbtree_delete_snotallb_2.svg))

#### S为红色

S为红，则P为黑，且其子结点为黑色。可以以P为支点，S-P-N的方向旋转，并交换S和P的着色：

![](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/rbtree_delete_sred.svg)

此时，`h(新P->SL->NIL)`、`h(新P->SR->NIL)`都没有变换，新P的着色跟原来一样，所以`h(G->NIL)`也没有变换。但是还没有平衡，因为`h(新P->N->NIL)`也没有变，但是N结点的兄弟结点变为了黑色，可以机选上节 **S为黑色** 继续处理。

## 参考

1. 《数据结构与算法分析 C++描述》
2. [wikipedia 红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)
3. [彻底理解红黑树（三）之 删除](https://www.jianshu.com/p/84416644c080)

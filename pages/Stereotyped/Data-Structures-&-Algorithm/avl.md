# AVL树

AVL（Adelson-Velskii and Landis）树是带有平衡条件的（balance condition）的二叉查找树：一颗AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树。

![左边是AVL树，右边不是](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/avl_demo.svg)

可以证明，数高为O(logN)。在假设 删除为懒惰删除 情况下，删除和查找都可以在简单地在O(logN)复杂度内执行。只有插入操作，因为可能会破坏平衡条件，需要做操作，我们称其为*旋转*（rotation）。在插入以后，只有那些从插入点到根结点的路径上的结点的平衡可能被改变，因此只有这些结点的可能需要平衡，我们沿着这条路径平衡该树。

## 插入

把当前需要平衡的结点记为N，AVL保证每个节点的两颗子树的高度最多差1，那么结点N两颗子树的高度差2。这种不平衡可能有以下4中情况：

1. N的**左**儿子的**左**子树进行一次插入
2. N的**左**儿子的**右**子树进行一次插入
3. N的**右**儿子的**右**子树进行一次插入
4. N的**右**儿子的**左**子树进行一次插入

情况1与情况3、情况2与情况4互为镜像问题，前者通过**单旋转**（single rotation）完成平衡，后者通过稍复杂的**双旋转**（double rotation）完成平衡。

### 单旋转

首先考虑情况1，“N-左-左”插入导致不平衡（N两子树高相差2）：“N-左-左”插入后肯定有导致“N-左”树高+1（树高不变 不会不平衡），而且插入前 “N-左”就比“N-右”高1，插入后“N-左”比“N-右”高2。如下图所示，通过右旋 减少“N-左”、增加“N-右” 达到平衡，且可以保证N的高度不变：

![](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/avl_single_rotation_R.svg)

类似的，考虑镜像问题“情况3”，左旋即可：

![](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/avl_single_rotation_L.svg)

### 双旋转

接下来考虑情况2，“N-左-右”插入导致不平衡（N两子树高相差2）：“N-左-右”插入后肯定有导致“N-左”树高+1（树高不变 不会不平衡），而且插入前 “N-左”就比“N-右”高1，插入后“N-左”比“N-右”高2。如下图所示，通过可以先对左子树左选，把内部高度差 转换为 边上高度差，再按情况1处理：

![](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/avl_double_rotation_LR.svg)

类似的，考虑镜像问题“情况4”，右旋+左旋 即可：

![](https://engineers-cool-1251518258.cos.ap-chengdu.myqcloud.com/avl_double_rotation_RL.svg)

## 删除

最后，如果删除次数很多，懒惰删除不适用，实时删除操作，也会导致树不平衡，此时也需要平衡。可以同样适用 单旋转 与 双旋转 处理高度差的问题，但是这会是的结点N的高度差少1，所以还会需要继续向上递归处理。

## 参考

1. 《数据结构与算法分析 C++描述》